# refs与事件处理

### 理解

组件内的标签可以定义ref属性来标识自己

###  编码

1. 字符串形式的ref
```
<input ref="input1"/>
```
2. 回调形式的ref
```
<input ref={(c)=>{this.input1 = c}}/> // c为标签对象
```
3. createRef 创建ref容器
```
myRef = React.createRef() 
// React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的

<input ref={this.myRef}/>
```



**勿过度使用 Refs**

##### 过时 API：String 类型的 Refs，因为 string 类型的 refs 存在一些性能上的问题，它已过时并可能会在未来的版本被移除。

#### 回调ref中回调执行次数的问题

如果 `ref` 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 `null`，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。


##  事件处理

1. 通过onXxx属性指定事件处理函数(注意大小写)
   1. React使用的是自定义(合成)事件, 而不是使用的原生DOM事件  ——— 为了更好的兼容性
   2. React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————为了的高效
   
2. 通过event.target得到发生事件的DOM元素对象—————不要过度使用ref

   

##  收集表单数据

###  理解

包含表单的组件分类

  1. 受控组件。 如输入框的输入 onChange事件setState新值。
  2. 非受控组件。 如表单提交  `event.preventDefault()` //阻止表单提交



### 高阶函数

  高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。

​   1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。

​   2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。

​   常见的高阶函数有：Promise、setTimeout、arr.map()等等


​  函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 
```
  function sum(a){
  
    return(b)=>{
  
      return (c)=>{
  
        return a+b+c
  
      }
  
    }
  
  }
```