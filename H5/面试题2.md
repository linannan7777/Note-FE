

# 1. 页面导入样式时，使用link和@import有什么区别？

在html设计制作中，css有四种引入方式。

方式一： 内联样式
内联样式，也叫行内样式，指的是直接在 HTML 标签中的 style 属性中添加 CSS。
示例：

```html
<div style="display: none;background:red"></div>
```



这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个 <div> 拥有相同的样式，你不得不重复地为每个 <div> 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。

方式二： 嵌入样式
嵌入方式指的是在 HTML 头部中的 <style> 标签下书写 CSS 代码。
示例：

```html
<head>
    <style>

    .content {
        background: red;
    }

    </style>
</head>
```



嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。

方式三：链接样式
链接方式指的是使用 HTML 头部的 标签引入外部的 CSS 文件。
示例：

```html
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
```



这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。

方式四：导入样式
导入方式指的是使用 CSS 规则引入外部 CSS 文件。
示例：

```html
<style>
    @import url(style.css);
</style>
```




或者写在css样式中

```css
@charset "utf-8";
@import url(style.css);
*{ margin:0; padding:0;}
.notice-link a{ color:#999;}
```


link和@import的区别？

区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。

区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
所以会出现一开始没有css样式，闪烁一下出现样式后的页面(网速慢的情况下)

区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。

补充：
@import最优写法
@import的写法一般有下列几种：
@import ‘style.css’ //Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别
@import “style.css” //Windows IE4/ NS4, Macintosh IE4/NS4不识别
@import url(style.css) //Windows NS4, Macintosh NS4不识别
@import url(‘style.css’) //Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别
@import url(“style.css”) //Windows NS4, Macintosh NS4不识别
由上分析知道，@import url(style.css) 和@import url(“style.css”)是最优的选择，兼容的浏览器最多。从字节优化的角度来看@import url(style.css)最值得推荐。

注意：@import url(xxx.css); 有最大次数的限制，经测试IE6的最大次数是31次，第32个import及以后的都不能生效。虽然最多只能import 31次，但不会影响css里面的其他规则，如body{}的定义还能正常显示。
Firefox 没有发现有import的最大值。 另外，既然纵向import有最大次数限制，却可以通过横向import来继续扩展。



# http和websocket能共用一个端口

您可以使用同一个端口处理多个不同的协议,但有一些注意事项：

- 服务器必须以某种方式检测(或协商)客户端希望发言的协议.您可以将单独的端口视为检测客户端希望发言的协议的常规方式.
- 只有一个服务器进程可以在端口上实际监听.该服务器可能仅用于检测协议类型,然后转发到多个其他服务器,但每个端口都由单个服务器进程拥有.
- 您不能支持服务器首先发出的多种协议(因为无法检测到客户端的协议).您可以支持具有多个客户端优先协议的单一服务器优先协议(通过在接受后添加一个短暂的延迟来查看客户端是否会发送数据),但这有点不合适.

WebSocket协议的明确设计目标是允许WebSocket和HTTP协议共享相同的服务器端口.最初的WebSocket握手是HTTP兼容的升级请求.

[websockify](javascript:void())服务器/网桥是可以在同一端口上说5种不同协议的服务器的示例：HTTP,HTTPS(加密HTTP),WS(WebSockets),WSS(加密WebSockets)和Flash策略响应.服务器在传入请求的第一个字符处达到峰值,以确定它是TLS加密的(HTTPS还是WSS),还是以“<”开头(Flash策略请求).如果是Flash策略请求,则会读取请求,响应并关闭连接.否则,它会读取HTTP握手(加密或不加密),“连接和升级”头连接确定是否为WebSocket请求或纯HTTP请求.

